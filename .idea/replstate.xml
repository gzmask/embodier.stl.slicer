<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1424733139388">{:repl-history {:ide [], :local [&quot;(flood [false true false])&quot; &quot;(let [a [1 2 3]\n      b (atom a)\n      _ (swap! b rest)]\n  [a @b]\n  )&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last not))]}\n  )&quot; &quot;(-&gt; t tree/leafs last not)&quot; &quot;{:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last not))]}&quot; &quot;(doc match\n     )&quot; &quot;(doc match)&quot; &quot;(match\n  )&quot; &quot;(match [1 1]\n       [1 _] true\n       [_ 1] false\n       :else nil)&quot; &quot;(match [2 2]\n       [1 _] true\n       [_ 1] false\n       :else nil)&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last not))]}\n  (match [(-&gt; t tree/leafs first not)\n          (-&gt; t tree/leafs last not)]\n         [true _] true\n         [_ true] false\n         :else nil)\n  )&quot; &quot;(flood [true false false])&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last not))]}\n  (match [(-&gt; t tree/leafs first not)\n          (-&gt; t tree/leafs last not)]\n         [false _] true\n         [_ false] false\n         :else nil)\n  )&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)]\n         [false _] true\n         [_ false] false\n         :else nil)\n  )&quot; &quot;(flood [true true false])&quot; &quot;[true true false]&quot; &quot;(inc 1)&quot; &quot;(leafs (range 1))&quot; &quot;(leafs (range 5))&quot; &quot;(leafs (range 21))&quot; &quot;(leafs (range 85))&quot; &quot;(flood [false true true true false])&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [false _ nil] true\n         [_ false nil] false\n         :else nil)\n  )&quot; &quot;(flood [false true true true true])&quot; &quot;(flood [true true true true true])&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first second not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last second not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [[_ false] _ nil] #(flood t )\n         [_ [_ false] nil] false\n         [_ _ node-index]\n         :else nil)\n  )&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first second not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last second not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [[i false] _ nil] #(flood t i)\n         [_ [i false] nil] #(flood t i)\n         [_ _ node-index]\n         :else nil)\n  )&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first second not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last second not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [[i false] _ nil] #(flood t i)\n         [_ [i false] nil] #(flood t i)\n         [_ _ node-index] false\n         :else nil)\n  )&quot; &quot;(flood [[0 true] [1 false] [2 true] [3 true] [4 true]])&quot; &quot;(tree/leafs [[0 true] [1 false] [2 true] [3 true] [4 true]])&quot; &quot;(tree/leafs [true false true true true])&quot; &quot;(flood [true false true true true])&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first second not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last second not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [[i false] _ nil] #(flood t i)\n         [_ [i false] nil] #(flood t i)\n         [_ _ node-index] node-index\n         :else nil)\n  )&quot; &quot;(trampoline (flood [true true true true false]))&quot; &quot;(trampoline (flood [true false true true true]))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (Math/pow tree-arity (- (:height hr) 3))\n               parent-row-count (Math/pow tree-arity (- (:height hr) 2))\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (Math/pow tree-arity (- (:height hr) 3))\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(parent 75)&quot; &quot;(parent 20)&quot; &quot;(parent 11)&quot; &quot;(Math/pow 4 3)&quot; &quot;(Math/pow 4 4\n          )&quot; &quot;(Math/pow 4 5\n          )&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (tree-node-count tree-arity (- (:height hr) 3))\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (tree-node-count (- (:height hr) 3) tree-arity)\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (tree-nodes-count (- (:height hr) 3) tree-arity)\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (tree-nodes-count (- (:height hr) 2) tree-arity)\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(parent 0)&quot; &quot;(parent 16)&quot; &quot;(tree-nodes-count 1 4)&quot; &quot;(tree-nodes-count 2 4)&quot; &quot;(tree-nodes-count 3 4)&quot; &quot;(tree-nodes-count 4 4)&quot; &quot;(tree-nodes-count 5 4)&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-node-count (tree-nodes-count (- (:height hr) 2) tree-arity)\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-node-count parent-row-index)))))&quot; &quot;(parent 17)&quot; &quot;(parent 341)&quot; &quot;(parent 85)&quot; &quot;(parent 21)&quot; &quot;(parent 5)&quot; &quot;(parent 1)&quot; &quot;(defn false-ancestor\n  \&quot;given a tree and an index of an nil node. returns its ancestor which is a false node\&quot;\n  [t i]\n  {:pre [(-&gt; t (nth i) nil?)]}\n  (loop [parent-node (parent i)]\n    (cond\n      (not (nth t parent-node)) parent-node\n      (nil? (nth t parent-node)) :no-false-ancestor\n      :else (recur (parent parent-node))\n      )\n    )\n  )&quot; &quot;(false-ancestor [false nil nil nil nil] 4)&quot; &quot;(defn false-ancestor\n  \&quot;given a tree and an index of an nil node. returns its ancestor which is a false node\&quot;\n  [t i]\n  {:pre [(-&gt; t (nth i) nil?)]}\n  (loop [parent-node (parent i)]\n    (cond\n      (not (nth t parent-node)) parent-node\n      :else (recur (parent parent-node))\n      )\n    )\n  )&quot; &quot;(defn false-ancestor\n  \&quot;given a tree and an index of an nil node. returns its ancestor which is a false node\&quot;\n  [t i]\n  {:pre [(-&gt; t (nth i) nil?)]}\n  (loop [parent-node (parent i)]\n    (cond\n      (false? (nth t parent-node)) parent-node\n      :else (recur (parent parent-node))\n      )\n    )\n  )&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 20)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 0)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 1)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 4)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 5)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 11)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 12)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 13)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 15)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 16)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 17)&quot; &quot;(set [1 true] [1 true])&quot; &quot;(set [[1 true] [1 true]])&quot; &quot;(vec (set [[1 true] [1 true]]))&quot; &quot;(leafs [\n        true\n        false\n        false\n        false\n        true\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        true\n        false\n        false\n        false])&quot; &quot;(leafs [true\n        false\n        false\n        false\n        true\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        true\n        false\n        false\n        false])&quot; &quot;(apply or (map #(= 1 %) #{1 2 3}))&quot; &quot;(map #(= 1 %) #{1 2 3})&quot; &quot;(contains? #{1 2 3} 1)&quot; &quot;(contains? #{1 2 3} 4)&quot; &quot;(conj #{} 1)&quot; &quot;(assoc #{} 1)&quot; &quot;(assoc #{} 1 2)&quot; &quot;(set nil)&quot; &quot;(set [true false false false false])&quot; &quot;(set [0 1 2 3 4])&quot; &quot;(defn adjacent\n  \&quot;given indexes of two nodes, returns if their AABB boxes are adjacent to each other\&quot;\n  [n1 n2 aabb]\n  {:pre [(integer? n1) (integer? n2)]}\n  (let [[min-x1 min-y1 max-x1 max-y1 :as n1-aabb] (index-to-aabb aabb tree-arity n1)\n        [min-x2 min-y2 max-x2 max-y2 :as n2-aabb] (index-to-aabb aabb tree-arity n2)]\n    (cond\n     (= min-x1 max-x2) true\n     (= min-x2 max-x1) true\n     (= min-y1 max-y2) true\n     (= min-y2 max-y1) true\n     :else false)))&quot; &quot;(defn aabb-inc\n  \&quot;given two aabb returns if they are intersecting with each other\&quot;\n  [[min-x1 min-y1 max-x1 max-y1 :as aabb1] [min-x2 min-y2 max-x2 max-y2 :as aabb2]]\n  (cond\n       (and\n        (or (and (&gt;= min-x2 min-x1) (&lt;= min-x2 max-x1))\n            (and (&gt;= max-x2 min-x1) (&lt;= max-x2 max-x1)))\n        (or (and (&gt;= min-y2 min-y1) (&lt;= min-y2 max-y1))\n            (and (&gt;= max-y2 min-y1) (&lt;= max-y2 max-y1)))) true\n     :else false))&quot; &quot;(defn node-inc\n  \&quot;given indexes of two nodes, returns if their AABB boxes are intersecting with each other\&quot;\n  [n1 n2 aabb]\n  {:pre [(integer? n1) (integer? n2)]}\n  (let [n1-aabb (index-to-aabb aabb tree-arity n1)\n        n2-aabb (index-to-aabb aabb tree-arity n2)]\n    (aabb-inc n1-aabb n2-aabb)))&quot; &quot;(use 'clojure.repl)&quot; &quot;(doc )&quot; &quot;(doc swap!)&quot; &quot;(defn flooding-aabb-gen\n  [[min-x min-y max-x max-y :as aabb]]\n  (let [w (- max-x min-x)\n        h (- max-y min-y)])\n  [[(- min-x w) min-y max-x max-y]\n   [max-x max-y max-x (+ max-y h)]\n   [max-x min-y (+ max-x w) max-y]\n   [min-x (- min-y h) max-x min-y]])&quot; &quot;(defn flooding-aabb-gen\n  [[min-x min-y max-x max-y :as aabb]]\n  (let [w (- max-x min-x)\n        h (- max-y min-y)]\n  [[(- min-x w) min-y max-x max-y]\n   [max-x max-y max-x (+ max-y h)]\n   [max-x min-y (+ max-x w) max-y]\n   [min-x (- min-y h) max-x min-y]]))&quot; &quot;(defn flood\n  \&quot;given a tree and aabb generated from the slice. with optional flooded nodes, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t aabb &amp; nodes]\n  (let [flooding-aabbs (if (empty? nodes)\n                         (flooding-aabb-gen aabb)\n                         (map #(tree/index-to-aabb aabb tree/tree-arity %) nodes))\n        leafs (tree/leafs t)\n        flooded-nodes (atom (set nodes))]\n    (loop [flooded-count (count @flooded-nodes)]\n      (doseq [leaf leafs\n              flooding-aabb flooding-aabbs]\n        (let [leaf-aabb (tree/index-to-aabb aabb tree/tree-arity leaf)]\n          (match [(tree/aabb-inc leaf-aabb flooding-aabb) (contains? @flooded-nodes leaf)]\n                 [true false] (swap! flooded-nodes (conj leaf)))))\n      (if (= (count @flooded-nodes) flooded-count)\n        @flooded-nodes\n        (recur (count @flooded-nodes))\n        )\n      )\n    )\n  )&quot; &quot;(defn flood\n  \&quot;given a tree and aabb generated from the slice. with optional flooded nodes, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t aabb &amp; nodes]\n  (let [flooding-aabbs (if (empty? nodes)\n                         (flooding-aabb-gen aabb)\n                         (map #(tree/index-to-aabb aabb tree/tree-arity %) nodes))\n        leafs (tree/leafs t)\n        flooded-nodes (atom (set nodes))]\n    (loop [flooded-count (count @flooded-nodes)]\n      (doseq [leaf leafs\n              flooding-aabb flooding-aabbs]\n        (let [leaf-aabb (tree/index-to-aabb aabb tree/tree-arity leaf)]\n          (match [(tree/aabb-inc leaf-aabb flooding-aabb) (contains? @flooded-nodes leaf)]\n                 [true false] (swap! flooded-nodes (conj leaf)))))\n      (if (= (count @flooded-nodes) flooded-count)\n        @flooded-nodes\n        (recur (count @flooded-nodes))))))&quot;], :remote []}}</component>
</project>