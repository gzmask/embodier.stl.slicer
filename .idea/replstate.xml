<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1424758438287">{:repl-history {:ide [], :local [&quot;(gui-main tree aabb [8])&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [false _ nil] true\n         [_ false nil] false\n         :else nil)\n  )&quot; &quot;(flood [false true true true true])&quot; &quot;(flood [true true true true true])&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first second not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last second not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [[_ false] _ nil] #(flood t )\n         [_ [_ false] nil] false\n         [_ _ node-index]\n         :else nil)\n  )&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first second not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last second not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [[i false] _ nil] #(flood t i)\n         [_ [i false] nil] #(flood t i)\n         [_ _ node-index]\n         :else nil)\n  )&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first second not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last second not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [[i false] _ nil] #(flood t i)\n         [_ [i false] nil] #(flood t i)\n         [_ _ node-index] false\n         :else nil)\n  )&quot; &quot;(flood [[0 true] [1 false] [2 true] [3 true] [4 true]])&quot; &quot;(tree/leafs [[0 true] [1 false] [2 true] [3 true] [4 true]])&quot; &quot;(tree/leafs [true false true true true])&quot; &quot;(flood [true false true true true])&quot; &quot;(defn flood\n  \&quot;given a tree generated from the slice, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t &amp; [node]]\n  {:pre [(or\n           ;first node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs first second not)\n           ;last node of the leafs of the tree is not collisded with the slice\n           (-&gt; t tree/leafs last second not))]}\n  (match [(-&gt; t tree/leafs first)\n          (-&gt; t tree/leafs last)\n          node]\n         [[i false] _ nil] #(flood t i)\n         [_ [i false] nil] #(flood t i)\n         [_ _ node-index] node-index\n         :else nil)\n  )&quot; &quot;(trampoline (flood [true true true true false]))&quot; &quot;(trampoline (flood [true false true true true]))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (Math/pow tree-arity (- (:height hr) 3))\n               parent-row-count (Math/pow tree-arity (- (:height hr) 2))\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (Math/pow tree-arity (- (:height hr) 3))\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(parent 75)&quot; &quot;(parent 20)&quot; &quot;(parent 11)&quot; &quot;(Math/pow 4 3)&quot; &quot;(Math/pow 4 4\n          )&quot; &quot;(Math/pow 4 5\n          )&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (tree-node-count tree-arity (- (:height hr) 3))\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (tree-node-count (- (:height hr) 3) tree-arity)\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (tree-nodes-count (- (:height hr) 3) tree-arity)\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-row-count (tree-nodes-count (- (:height hr) 2) tree-arity)\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-row-count parent-row-index)))))&quot; &quot;(parent 0)&quot; &quot;(parent 16)&quot; &quot;(tree-nodes-count 1 4)&quot; &quot;(tree-nodes-count 2 4)&quot; &quot;(tree-nodes-count 3 4)&quot; &quot;(tree-nodes-count 4 4)&quot; &quot;(tree-nodes-count 5 4)&quot; &quot;(defn parent\n  \&quot;given a node index, returns parent index\&quot;\n  [i]\n  {:pre [(integer? i)]}\n  (cond\n   (= i 0) nil\n   (&lt; i 5) 0\n   :else (let [hr (index-to-hrp i tree-arity)\n               grandparent-node-count (tree-nodes-count (- (:height hr) 2) tree-arity)\n               parent-row-index (Math/floor (/ (:row-index hr) tree-arity))]\n           (int (+ grandparent-node-count parent-row-index)))))&quot; &quot;(parent 17)&quot; &quot;(parent 341)&quot; &quot;(parent 85)&quot; &quot;(parent 21)&quot; &quot;(parent 5)&quot; &quot;(parent 1)&quot; &quot;(defn false-ancestor\n  \&quot;given a tree and an index of an nil node. returns its ancestor which is a false node\&quot;\n  [t i]\n  {:pre [(-&gt; t (nth i) nil?)]}\n  (loop [parent-node (parent i)]\n    (cond\n      (not (nth t parent-node)) parent-node\n      (nil? (nth t parent-node)) :no-false-ancestor\n      :else (recur (parent parent-node))\n      )\n    )\n  )&quot; &quot;(false-ancestor [false nil nil nil nil] 4)&quot; &quot;(defn false-ancestor\n  \&quot;given a tree and an index of an nil node. returns its ancestor which is a false node\&quot;\n  [t i]\n  {:pre [(-&gt; t (nth i) nil?)]}\n  (loop [parent-node (parent i)]\n    (cond\n      (not (nth t parent-node)) parent-node\n      :else (recur (parent parent-node))\n      )\n    )\n  )&quot; &quot;(defn false-ancestor\n  \&quot;given a tree and an index of an nil node. returns its ancestor which is a false node\&quot;\n  [t i]\n  {:pre [(-&gt; t (nth i) nil?)]}\n  (loop [parent-node (parent i)]\n    (cond\n      (false? (nth t parent-node)) parent-node\n      :else (recur (parent parent-node))\n      )\n    )\n  )&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 20)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 0)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 1)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 4)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 5)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 11)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 12)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 13)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 15)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 16)&quot; &quot;(false-ancestor [false nil nil nil false nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] 17)&quot; &quot;(set [1 true] [1 true])&quot; &quot;(set [[1 true] [1 true]])&quot; &quot;(vec (set [[1 true] [1 true]]))&quot; &quot;(leafs [\n        true\n        false\n        false\n        false\n        true\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        true\n        false\n        false\n        false])&quot; &quot;(leafs [true\n        false\n        false\n        false\n        true\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        nil\n        true\n        false\n        false\n        false])&quot; &quot;(apply or (map #(= 1 %) #{1 2 3}))&quot; &quot;(map #(= 1 %) #{1 2 3})&quot; &quot;(contains? #{1 2 3} 1)&quot; &quot;(contains? #{1 2 3} 4)&quot; &quot;(conj #{} 1)&quot; &quot;(assoc #{} 1)&quot; &quot;(assoc #{} 1 2)&quot; &quot;(set nil)&quot; &quot;(set [true false false false false])&quot; &quot;(set [0 1 2 3 4])&quot; &quot;(defn adjacent\n  \&quot;given indexes of two nodes, returns if their AABB boxes are adjacent to each other\&quot;\n  [n1 n2 aabb]\n  {:pre [(integer? n1) (integer? n2)]}\n  (let [[min-x1 min-y1 max-x1 max-y1 :as n1-aabb] (index-to-aabb aabb tree-arity n1)\n        [min-x2 min-y2 max-x2 max-y2 :as n2-aabb] (index-to-aabb aabb tree-arity n2)]\n    (cond\n     (= min-x1 max-x2) true\n     (= min-x2 max-x1) true\n     (= min-y1 max-y2) true\n     (= min-y2 max-y1) true\n     :else false)))&quot; &quot;(defn aabb-inc\n  \&quot;given two aabb returns if they are intersecting with each other\&quot;\n  [[min-x1 min-y1 max-x1 max-y1 :as aabb1] [min-x2 min-y2 max-x2 max-y2 :as aabb2]]\n  (cond\n       (and\n        (or (and (&gt;= min-x2 min-x1) (&lt;= min-x2 max-x1))\n            (and (&gt;= max-x2 min-x1) (&lt;= max-x2 max-x1)))\n        (or (and (&gt;= min-y2 min-y1) (&lt;= min-y2 max-y1))\n            (and (&gt;= max-y2 min-y1) (&lt;= max-y2 max-y1)))) true\n     :else false))&quot; &quot;(defn node-inc\n  \&quot;given indexes of two nodes, returns if their AABB boxes are intersecting with each other\&quot;\n  [n1 n2 aabb]\n  {:pre [(integer? n1) (integer? n2)]}\n  (let [n1-aabb (index-to-aabb aabb tree-arity n1)\n        n2-aabb (index-to-aabb aabb tree-arity n2)]\n    (aabb-inc n1-aabb n2-aabb)))&quot; &quot;(use 'clojure.repl)&quot; &quot;(doc )&quot; &quot;(doc swap!)&quot; &quot;(defn flooding-aabb-gen\n  [[min-x min-y max-x max-y :as aabb]]\n  (let [w (- max-x min-x)\n        h (- max-y min-y)])\n  [[(- min-x w) min-y max-x max-y]\n   [max-x max-y max-x (+ max-y h)]\n   [max-x min-y (+ max-x w) max-y]\n   [min-x (- min-y h) max-x min-y]])&quot; &quot;(defn flooding-aabb-gen\n  [[min-x min-y max-x max-y :as aabb]]\n  (let [w (- max-x min-x)\n        h (- max-y min-y)]\n  [[(- min-x w) min-y max-x max-y]\n   [max-x max-y max-x (+ max-y h)]\n   [max-x min-y (+ max-x w) max-y]\n   [min-x (- min-y h) max-x min-y]]))&quot; &quot;(defn flood\n  \&quot;given a tree and aabb generated from the slice. with optional flooded nodes, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t aabb &amp; nodes]\n  (let [flooding-aabbs (if (empty? nodes)\n                         (flooding-aabb-gen aabb)\n                         (map #(tree/index-to-aabb aabb tree/tree-arity %) nodes))\n        leafs (tree/leafs t)\n        flooded-nodes (atom (set nodes))]\n    (loop [flooded-count (count @flooded-nodes)]\n      (doseq [leaf leafs\n              flooding-aabb flooding-aabbs]\n        (let [leaf-aabb (tree/index-to-aabb aabb tree/tree-arity leaf)]\n          (match [(tree/aabb-inc leaf-aabb flooding-aabb) (contains? @flooded-nodes leaf)]\n                 [true false] (swap! flooded-nodes (conj leaf)))))\n      (if (= (count @flooded-nodes) flooded-count)\n        @flooded-nodes\n        (recur (count @flooded-nodes))\n        )\n      )\n    )\n  )&quot; &quot;(defn flood\n  \&quot;given a tree and aabb generated from the slice. with optional flooded nodes, flood the tree from outside and return the nodes that are flooded\&quot;\n  [t aabb &amp; nodes]\n  (let [flooding-aabbs (if (empty? nodes)\n                         (flooding-aabb-gen aabb)\n                         (map #(tree/index-to-aabb aabb tree/tree-arity %) nodes))\n        leafs (tree/leafs t)\n        flooded-nodes (atom (set nodes))]\n    (loop [flooded-count (count @flooded-nodes)]\n      (doseq [leaf leafs\n              flooding-aabb flooding-aabbs]\n        (let [leaf-aabb (tree/index-to-aabb aabb tree/tree-arity leaf)]\n          (match [(tree/aabb-inc leaf-aabb flooding-aabb) (contains? @flooded-nodes leaf)]\n                 [true false] (swap! flooded-nodes (conj leaf)))))\n      (if (= (count @flooded-nodes) flooded-count)\n        @flooded-nodes\n        (recur (count @flooded-nodes))))))&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t [min-x min-y max-x max-y :as aabb] nodes]\n  (let [[p1 p2 p3 p4] (aabb-points aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw #((q/stroke 0)             ;; Set the stroke colour to a random grey\n               (q/stroke-weight 1)       ;; Set the stroke thickness randomly\n               (q/fill 128)               ;; Set the fill colour to a random grey\n               (q/line p2 p1))\n        ]\n    (q/sketch ;; Define a new sketch named example\n                 :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n                 :setup setup                        ;; Specify the setup fn\n                 :draw draw                          ;; Specify the draw fn\n                 :size [640 480])\n    )\n  )&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t [min-x min-y max-x max-y :as aabb] nodes]\n  (let [[p1 p2 p3 p4] (aabb-points aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw #((q/stroke 0)             ;; Set the stroke colour to a random grey\n               (q/stroke-weight 1)       ;; Set the stroke thickness randomly\n               (q/fill 128)               ;; Set the fill colour to a random grey\n               (q/line 2 1))\n        ]\n    (q/sketch ;; Define a new sketch named example\n                 :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n                 :setup setup                        ;; Specify the setup fn\n                 :draw draw                          ;; Specify the draw fn\n                 :size [640 480])\n    )\n  )&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t aabb nodes]\n  (let [[p1 p2 p3 p4] (aabb-pionts aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw #((q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n               (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n               (q/fill (q/random 0))               ;; Set the fill colour to a random grey\n               (q/line p1 p2)\n               (q/line p2 p3)\n               (q/line p3 p4)\n               (q/line p4 p1))\n        ]\n    (q/sketch ;; Define a new sketch named example\n                 :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n                 :setup setup                        ;; Specify the setup fn\n                 :draw draw                          ;; Specify the draw fn\n                 :size [323 200])\n    )\n  )&quot; &quot;(defn aabb-points\n  \&quot;given AABB, returns the four points\&quot;\n  [[min-x min-y max-x max-y :as aabb]]\n  [[min-x min-y]\n   [min-x max-y]\n   [max-x max-y]\n   [max-x min-y]])&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t aabb nodes]\n  (let [[p1 p2 p3 p4] (aabb-points aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw #((q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n               (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n               (q/fill (q/random 0))               ;; Set the fill colour to a random grey\n               (q/line p1 p2)\n               (q/line p2 p3)\n               (q/line p3 p4)\n               (q/line p4 p1))\n        ]\n    (q/sketch ;; Define a new sketch named example\n                 :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n                 :setup setup                        ;; Specify the setup fn\n                 :draw draw                          ;; Specify the draw fn\n                 :size [323 200])\n    )\n  )&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t aabb nodes]\n  (let [[p1 p2 p3 p4] (aabb-points aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw #((q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n               (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n               (q/with-translation [(/ (q/width) 2) (/ (q/height) 2)]\n               (q/line p1 p2) (q/line p2 p3) (q/line p3 p4) (q/line p4 p1)))\n        ]\n    (q/sketch ;; Define a new sketch named example\n                 :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n                 :setup setup                        ;; Specify the setup fn\n                 :draw draw                          ;; Specify the draw fn\n                 :size [323 200])\n    )\n  )&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t aabb nodes]\n  (let [[p1 p2 p3 p4] (aabb-points aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw #((q/with-translation [(/ (q/width) 2) (/ (q/height) 2)]\n                                   (q/line p1 p2) (q/line p2 p3) (q/line p3 p4) (q/line p4 p1)))\n        ]\n    (q/sketch ;; Define a new sketch named example\n                 :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n                 :setup setup                        ;; Specify the setup fn\n                 :draw draw                          ;; Specify the draw fn\n                 :size [323 200])\n    )\n  )&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t aabb nodes]\n  (let [[p1 p2 p3 p4] (aabb-points aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw- #((q/with-translation [(/ (q/width) 2) (/ (q/height) 2)]\n                                   (q/line p1 p2) (q/line p2 p3) (q/line p3 p4) (q/line p4 p1)))\n        draw #((q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n               (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n               (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n               (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n                     x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n                     y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n                 (q/ellipse x y diam diam)))\n        ]\n    (q/sketch ;; Define a new sketch named example\n                 :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n                 :setup setup                        ;; Specify the setup fn\n                 :draw draw                          ;; Specify the draw fn\n                 :size [323 200])\n    )\n  )&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t aabb nodes]\n  (let [[p1 p2 p3 p4] (aabb-points aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw- #((q/with-translation [(/ (q/width) 2) (/ (q/height) 2)]\n                                   (q/line p1 p2) (q/line p2 p3) (q/line p3 p4) (q/line p4 p1)))\n        draw #((q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n               (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n               (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n               (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n                     x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n                     y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n                 (q/ellipse x y diam diam)))\n        ]\n    (q/defsketch namess;; Define a new sketch named example\n                 :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n                 :setup setup                        ;; Specify the setup fn\n                 :draw draw                          ;; Specify the draw fn\n                 :size [323 200])\n    )\n  )&quot; &quot;(defn ssetup []\n  (q/smooth)                          ;; Turn on anti-aliasing\n  (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n  (q/background 200))&quot; &quot;(defn ddraw [] \n  (q/with-translation [(/ (q/width) 2) (/ (q/height) 2)]\n                      (q/line p1 p2) (q/line p2 p3) (q/line p3 p4) (q/line p4 p1)))&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t aabb nodes]\n  (let [[p1 p2 p3 p4] (aabb-points aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw- #((q/with-translation [(/ (q/width) 2) (/ (q/height) 2)]\n                                   (q/line p1 p2) (q/line p2 p3) (q/line p3 p4) (q/line p4 p1)))\n        draw #((q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n               (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n               (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n               (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n                     x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n                     y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n                 (q/ellipse x y diam diam)))\n        ]\n    (q/sketch  :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n               :setup ssetup                        ;; Specify the setup fn\n               :draw ddraw                          ;; Specify the draw fn\n               :size [323 200])\n    )\n  )&quot; &quot;(defn ddraw- [] (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey\n               (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly\n               (q/fill (q/random 255))               ;; Set the fill colour to a random grey\n\n               (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100\n                     x    (q/random (q/width))       ;; Set the x coord randomly within the sketch\n                     y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch\n                 (q/ellipse x y diam diam)))&quot; &quot;(defn ddraw []\n  (q/with-translation [(/ (q/width) 2) (/ (q/height) 2)]\n                      (q/line -10 -10 -10 10) (q/line -10 10 10 10)))&quot; &quot;(q/defsketch example                  ;; Define a new sketch named example\n             :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n             :setup ssetup                        ;; Specify the setup fn\n             :draw ddraw-\n             :size [323 200])&quot; &quot;(q/defsketch example                  ;; Define a new sketch named example\n             :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n             :setup ssetup                        ;; Specify the setup fn\n             :draw ddraw\n             :size [323 200])&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t aabb nodes]\n  (let [[[x1 y1] [x2 y2] [x3 y3] [x4 y4]] (aabb-points aabb)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw #((q/with-translation [(/ (q/width) 2) (/ (q/height) 2)]\n                                   (q/line x1 y1 x2 y2) (q/line x2 y2 x3 y3) (q/line x3 y3 x4 y4) (q/line x4 y4 x1 y1)))\n        ]\n    (q/defsketch somename  :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n               :setup setup                        ;; Specify the setup fn\n               :draw draw                          ;; Specify the draw fn\n               :size [323 200])\n    )\n  )&quot; &quot;(defn gui-main\n  \&quot;the gui engine\&quot;\n  [t [min-x min-y max-x max-y :as aabb] nodes]\n  (let [[[x1 y1] [x2 y2] [x3 y3] [x4 y4]] (aabb-points aabb)\n        h (- max-y min-y)\n        hpx (/ 480 h)\n        w (- max-x min-x)\n        wpx (/ 640 w)\n        setup #((q/smooth)                          ;; Turn on anti-aliasing\n                (q/frame-rate 1)                    ;; Set framerate to 1 FPS\n                (q/background 200))\n        draw #(q/with-translation [(/ (q/width) 2) (/ (q/height) 2)]\n                                  (-&gt;&gt; [x1 y1 x2 y2] (map * [wpx hpx wpx hpx]) (apply q/line))\n                                  (-&gt;&gt; [x2 y2 x3 y3] (map * [wpx hpx wpx hpx]) (apply q/line))\n                                  (-&gt;&gt; [x3 y3 x4 y4] (map * [wpx hpx wpx hpx]) (apply q/line))\n                                  (-&gt;&gt; [x4 y4 x1 y1] (map * [wpx hpx wpx hpx]) (apply q/line)))\n        ]\n    (q/sketch  :title \&quot;Oh so many grey circles\&quot;    ;; Set the title of the sketch\n               :setup setup                        ;; Specify the setup fn\n               :draw draw                          ;; Specify the draw fn\n               :size [640 480])\n    )\n  )&quot; &quot;(gui-main [true false false false true nil nil nil nil nil nil nil nil nil nil nil nil false false false nil]\n          [-10 -10 10 10]\n          [0 4 20])&quot; &quot;(inc 1\n     )&quot; &quot;(+ 1 1)&quot;], :remote []}}</component>
</project>