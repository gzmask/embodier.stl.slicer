(ns slicer.gcode
  (:require [slicer.slice :as slice]
            [slicer.util :refer :all]
            [slicer.file :as file]
            [slicer.tree :as tree]
            [slicer.flood :as flood]
            [slicer.draw :as draw]
            [slicer.eulerian :as eulerian])
  (:use clojure.java.io))

(def header-str
  "; generated by embodier 0.0.1")

;this funciton is just a placepo for watertight, outline, infill, traversal and extruding accumulation
(defn gcode
  [cuts]
  (apply str
    (for [cut cuts]
      (let [z-str (str "G1 Z" (:cut-point cut) \newline)
            xy-str (let [slice (:result cut)
                         _ (debugger slice "slice:")
                         tree (tree/generate-tree slice 1 2)
                         aabb (-> slice (tree/aabb-slice 2) tree/make-square)
                         flooded-leafs (flood/fast-flood tree aabb slice)
                         fixing-set (eulerian/convert-to-eulerian flooded-leafs tree aabb)
                         edges (eulerian/all-edges flooded-leafs tree aabb fixing-set)
                         edge-path (eulerian/hierholzer edges flooded-leafs [])
                         points (eulerian/edge-to-points edge-path aabb)]
                     (apply str
                            (for [p points]
                              (str "G1 X" (first p) " Y" (second p) " E1" \newline))))]
        (str z-str (apply str xy-str))))))

(defn write-gcode
  [gcode-file gcode-str]
  (with-open [g (writer (file gcode-file))]
    (.write g gcode-str)))
